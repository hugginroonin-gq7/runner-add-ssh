/**
 * Linux Executor
 * 
 * Handles SSH installation, configuration, and service management on Linux.
 */

const path = require('path');
const { spawnAsync, execSudo } = require('../../adapters/process');
const { writeFile, ensureDir, readFile, exists } = require('../../adapters/fs');
const { ProcessError } = require('../../utils/errors');

/**
 * Install OpenSSH Server on Linux
 * 
 * @param {Object} config - Configuration
 * @param {Logger} logger - Logger instance
 */
async function installSSH(config, logger) {
  try {
    // Update package list
    logger.debug('Updating package list...');
    await execSudo(['apt-get', 'update', '-y'], logger);

    // Install openssh-server
    logger.debug('Installing openssh-server...');
    await execSudo(['apt-get', 'install', '-y', 'openssh-server'], logger);

    logger.debug('OpenSSH Server installed successfully');
  } catch (error) {
    throw new ProcessError(`Failed to install OpenSSH Server: ${error.message}`);
  }
}

/**
 * Configure SSH Server on Linux
 * 
 * @param {Object} config - Configuration
 * @param {Logger} logger - Logger instance
 */
async function configureSSH(config, logger) {
  const sshdConfigPath = '/etc/ssh/sshd_config';

  try {
    // Generate sshd_config content
    const sshdConfig = generateSSHDConfig(config);

    // Write config file (requires sudo)
    logger.debug(`Writing sshd_config to ${sshdConfigPath}...`);
    
    // Write to temp file first
    const tempConfigPath = path.join(config.cwd, '.runner-data', 'tmp', 'sshd_config');
    await ensureDir(path.dirname(tempConfigPath));
    await writeFile(tempConfigPath, sshdConfig);

    // Copy to /etc/ssh/ with sudo
    await execSudo(['cp', tempConfigPath, sshdConfigPath], logger);

    // Set proper permissions
    await execSudo(['chmod', '644', sshdConfigPath], logger);

    // Ensure runtime directory exists for privilege separation
    logger.debug('Ensuring /run/sshd exists...');
    await execSudo(['mkdir', '-p', '/run/sshd'], logger);
    await execSudo(['chmod', '755', '/run/sshd'], logger);

    // Ensure host keys exist
    logger.debug('Ensuring SSH host keys exist...');
    await execSudo(['ssh-keygen', '-A'], logger);

    // Test configuration
    logger.debug('Testing sshd configuration...');
    await execSudo(['sshd', '-t'], logger);

    logger.debug('SSH configuration applied successfully');
  } catch (error) {
    throw new ProcessError(`Failed to configure SSH: ${error.message}`);
  }
}

/**
 * Start SSH service on Linux
 * 
 * @param {Object} config - Configuration
 * @param {Logger} logger - Logger instance
 */
async function startSSH(config, logger) {
  try {
    // Enable SSH service to start on boot
    logger.debug('Enabling SSH service...');
    await execSudo(['systemctl', 'enable', 'ssh'], logger);

    // Restart SSH service
    logger.debug('Restarting SSH service...');
    await execSudo(['systemctl', 'restart', 'ssh'], logger);

    // Check service status
    logger.debug('Checking SSH service status...');
    try {
      await execSudo(['systemctl', 'is-active', 'ssh'], logger);
      logger.debug('SSH service is active');
    } catch (err) {
      // Try 'sshd' instead of 'ssh'
      await execSudo(['systemctl', 'restart', 'sshd'], logger);
      await execSudo(['systemctl', 'is-active', 'sshd'], logger);
      logger.debug('SSH service (sshd) is active');
    }

  } catch (error) {
    throw new ProcessError(`Failed to start SSH service: ${error.message}`);
  }
}

/**
 * Generate sshd_config content
 * 
 * @param {Object} config - Configuration
 * @returns {string} sshd_config content
 */
function generateSSHDConfig(config) {
  const allowUsersArr = config.allowUsers.split(' ').filter(u => u.trim());

  return `# SSH Server Configuration - Generated by runner-add-ssh
# Port
Port ${config.port}

# Authentication
PubkeyAuthentication yes
PasswordAuthentication no
ChallengeResponseAuthentication no
UsePAM yes

# Security
PermitRootLogin ${config.mode === 'root' ? 'prohibit-password' : 'no'}
StrictModes yes
MaxAuthTries 3
MaxSessions 10

# Allowed users
AllowUsers ${allowUsersArr.join(' ')}

# Subsystems
Subsystem sftp internal-sftp

# Logging
SyslogFacility AUTH
LogLevel INFO

# Performance
UseDNS no
`;
}

/**
 * Configure default working directory for interactive SSH shells.
 *
 * Uses ~/.bashrc hook instead of ForceCommand so SFTP/SCP are not affected.
 *
 * @param {Object} config - Configuration
 * @param {Logger} logger - Logger instance
 */
async function configureDefaultCwd(config, logger) {
  if (config.disableForceCwd) {
    return;
  }

  const bashrcPath = path.join(config.homeDir, '.bashrc');
  const startMarker = '# runner-add-ssh: default-cwd:start';
  const endMarker = '# runner-add-ssh: default-cwd:end';
  const block = [
    startMarker,
    'if [ -n "$SSH_CONNECTION" ] && [ -n "$PS1" ] && [ -d ' + quoteForShellSingle(config.defaultCwd) + ' ]; then',
    '  cd ' + quoteForShellSingle(config.defaultCwd) + ' >/dev/null 2>&1 || true',
    'fi',
    endMarker
  ].join('\n');

  try {
    let currentContent = '';

    if (await exists(bashrcPath)) {
      currentContent = await readFile(bashrcPath);
    }

    const blockRegex = /# runner-add-ssh: default-cwd:start[\s\S]*?# runner-add-ssh: default-cwd:end\s*/g;
    const cleaned = currentContent.replace(blockRegex, '').trimEnd();
    const nextContent = cleaned ? `${cleaned}\n\n${block}\n` : `${block}\n`;

    await writeFile(bashrcPath, nextContent);
    logger.debug(`Configured interactive SSH default cwd in ${bashrcPath}`);
  } catch (error) {
    logger.warn(`Could not configure default SSH login directory in .bashrc: ${error.message}`);
  }
}

function quoteForShellSingle(value) {
  return `'${String(value).replace(/'/g, `'\"'\"'`)}'`;
}

module.exports = {
  installSSH,
  configureSSH,
  configureDefaultCwd,
  startSSH
};
